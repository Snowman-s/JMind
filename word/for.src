for単語情報型は　型紙
        for単語名は　文字列
        forループカウンタ増加数は　変数
        for終了判定オペコードは　変数
        ※渡された数値を使用する場所
        ※(0か1であること)
        ※0の時
        ※for(int i = 1;i <= n;i++)
        ※1の時
        ※for(int i = n;i <= 1;i++)
        for譲渡値使用場所は　変数

    for単語情報は
        for単語名と
        forループカウンタ増加数と
        for終了判定オペコードと
        for譲渡値使用場所
    全体は　２個の　for単語情報。

for単語情報集は　暗黙の構造体　for単語情報型。

（・ー＞・）
for単語情報集を初期化とは
    for単語情報集の　for単語名（１）に　「回数指定」を　入れ
    ０で　if_icmpgtのデータを得て、　(バイト数を)　捨て、
    for単語情報集の　for終了判定オペコード（１）に　入れ
    for単語情報集の　forループカウンタ増加数（１）に　１を　入れ
    for単語情報集の　for譲渡値使用場所（１）に　０を　入れ

    for単語情報集の　for単語名（２）に　「逆向回数指定」を　入れ
    ０で　if_icmpltのデータを得て、　(バイト数を)　捨て、
    for単語情報集の　for終了判定オペコード（２）に　入れ
    for単語情報集の　forループカウンタ増加数（２）に　－１を　入れ
    for単語情報集の　for譲渡値使用場所（２）に　１を　入れ。

（文字列ー＞インデックス・真）
（文字列ー＞偽）
定義済みfor単語？とは
    検査文字列は　文字列
    検査文字列に　入れ
    for単語情報の　要素数を　回数指定し、
        for単語情報集の　for単語名（回数）と　検査文字列が　等しい文字列　ならば
            回数と　真をつみ　終わり
        つぎに
    繰り返し、
    偽を　返すこと。

（インデックスー＞）
（Integerインデックス・IntegerIntValueインデックス・追加した定数フィールド数）
for単語の定数フィールドを追加するとは
    インデックスは　変数
    追加数は　変数

    （文字列・バイトー＞・）
    文字列化して追加とは
        バイト数指定で文字列化したものを、
        ランタイム定数フィールドをメモファイルに書き込み

    本体とは
        インデックスに　入れ
        追加数を　クリアし

        メソッドランタイム定数フィールド数と　「java/lang/Integer」で
            クラスランタイム定数フィールド情報を得て　偽？　ならば
            ランタイム定数フィールドをメモファイルに書き込み
            追加数を　増加させ
        つぎに

        ※！！！
        (Integerインデックスが積まれた)

        ※Methodref
        メソッドランタイム定数フィールド数に　追加数を　加え
        「java/lang/Integer」と　「intValue」と　「()I」で
            Methodランタイム定数フィールド情報を得て　偽？　ならば
            ランタイム定数フィールドをメモファイルに書き込み
            追加数を　増加させ
        つぎに

            ※！！！
        (IntValueインデックスが積まれた)

        メソッドランタイム定数フィールド数を
        追加数だけ　増加させ。

※        nをこれまでに使用されたローカル変数の数とすると
※        17: aload_1
※        18: invokevirtual #20                 // Method java/util/Stack.pop:()Ljava/lang/Object;
※        21: checkcast     #11                 // class java/lang/Integer
※        24: invokevirtual #24                 // Method java/lang/Integer.intValue:()I
※        27: istore_<n> //ループカウンタ最大値
※        28: iconst_1
※        29: istore_<n+1> //ループカウンタ

※        30: iload_<n+1>
※        31: iload_<n>
※        32: if_icmpgt     58

※        //ループ内処理

※        52: iinc          <n+2>, 1
※        55: goto          30
単語認識for単語時の処理とは、
    インデックスは　変数
    オフセットは　変数
    Integer定義インデックスは　変数
    IntegerIntValue定義インデックスは　変数
    関数認識構造体情報は　構造体情報
    forオフセットは　変数

    for開始時バイト数は　変数
    書き換え予定ifバイト数は　変数
    for終了時バイト数は　変数

    forループカウンタ最大値変数インデックスは　変数
    forループカウンタ変数インデックスは　変数

    回数変数インデックスストックは　変数
        for枠取り変数数は　定数　２

    本体とは
    インデックスに　入れ

    オフセットに　メソッドランタイム定数フィールド数を　入れ
    「これはfor単語です」を　文字列をテスト表示し、

    ※ループカウンタの為の変数
        メソッドローカル変数を一つ枠取り
        forループカウンタ最大値変数インデックスに　入れ

        メソッドローカル変数を一つ枠取り
        forループカウンタ変数インデックスに　入れ

        回数変数インデックスを
        回数変数インデックスストックに　入れ

        forループカウンタ変数インデックスを
        回数変数インデックスに　入れ
        ※！！！変数
        ローカル変数メモファイル追加書き込み準備し、
        for枠取り変数数を　回数指定し
            Integerのスタックマップテーブルデータを得て
            ローカル変数のバイナリを文字列追加することを
        繰り返し
    インデックスをつかい
    for単語の定数フィールドを追加し、

    Integer定義インデックスと
    IntegerIntValue定義インデックスに　入れ

    ※aload_1
    Stackaloadのデータを得て　オペコードのバイナリを追加し
    ※invokevirtual //Method
    pop関数を得て、invokevirtualのデータを得て　オペコードのバイナリを追加し
    ※checkcast
    Integer定義インデックスで
    checkcastのデータを得て、オペコードのバイナリを追加し
    ※invokevirtual
    IntegerIntValue定義インデックスで
    invokevirtualのデータを得て　オペコードのバイナリを追加し
    
    ※istore_<n>
    for譲渡値使用場所（インデックス）が　０に　等しい　ならば
        forループカウンタ変数インデックスをつみ
        forループカウンタ最大値変数インデックスをつみ
    さもなければ
        forループカウンタ最大値変数インデックスをつみ
        forループカウンタ変数インデックスをつみ
    つぎに
    istoreのデータを可能なら短縮して得て　オペコードのバイナリを追加し
    ※iconst_1
    １で　iconst_iのデータを得て　オペコードのバイナリを追加し
    ※istore_<n+1>
    istoreのデータを可能なら短縮して得て　オペコードのバイナリを追加し

        真で　オペコードメモバイト数を
        for開始時バイト数に　入れ

    ※iload_<n+1>
    forループカウンタ変数インデックスで
    iloadのデータを可能なら短縮して得て　オペコードのバイナリを追加し
    ※iload_<n>
    forループカウンタ最大値変数インデックスで
    iloadのデータを可能なら短縮して得て　オペコードのバイナリを追加し

        真で　オペコードメモバイト数を
        書き換え予定ifバイト数に　入れ

        ※！！！スタックマップテーブル
        for開始時バイト数より
        メソッドスタックマップテーブルオフセットを　引き
        forオフセットに　入れ

        forオフセットが　０　以上　ならば
            ０ＦＦＨを
            １バイトで　スタックマップテーブルのバイナリを追加し

            forオフセットを
            ２バイトで　スタックマップテーブルのバイナリを追加し

            for開始時バイト数に　一つ加え
            メソッドスタックマップテーブルオフセットに　入れ

            現在使用中のメソッドローカル変数数を
            ２バイトで　スタックマップテーブルのバイナリを追加し

            ローカル変数メモファイル読み出し準備し
            メモされたローカル変数をスタックマップテーブルメモファイルに書き込み

            ０を
            ２バイトで　スタックマップテーブルのバイナリを追加し
            メソッドスタックマップテーブル情報数を　一つ増加し
        つぎに

    ※if_<exp>
    for終了判定オペコード（インデックス）で
    ３バイトで
    オペコードのバイナリを追加し

    「繰返」まで　羅列文字列認識し

    ※iinc <n+1>
    forループカウンタ変数インデックスで
    forループカウンタ増加数（インデックス）だけ
    iincのデータを得て　オペコードのバイナリを追加し
    ※goto
    for開始時バイト数より
    真をつかい　オペコードメモバイト数をえて
    引き
    gotoのデータを得て
    オペコードのバイナリを追加し、

        真で　オペコードメモバイト数を
        for終了時バイト数に　入れ

    for終了時バイト数から　for開始時バイト数を　引いたものより
    書き換え予定ifバイト数から　for開始時バイト数を　引いたものを
    引き
    ２バイトで　バイト数指定で文字列化したもので、

    書き換え予定ifバイト数に　１つ　加え
    オペコードメモファイルを一部変更し

    回数変数インデックスに
    回数変数インデックスストックを　入れ
    ２バイトで　ローカル変数メモファイルを指定バイト削除し
    現在使用中のメソッドローカル変数数を　２つ　減少させ
    ※！！！！スタックマップテーブル

        for終了時バイト数より
        メソッドスタックマップテーブルオフセットを　引き
        forオフセットに　入れ

        forオフセットが　－１と　異なる　ならば
            ０Ｆ９Ｈを
            １バイトで　スタックマップテーブルのバイナリを追加し

            forオフセットを
            ２バイトで　スタックマップテーブルのバイナリを追加し

            for終了時バイト数に　一つ加え
            メソッドスタックマップテーブルオフセットに　入れ

            メソッドスタックマップテーブル情報数を　一つ増加し
        つぎに。